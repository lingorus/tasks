# tasks
Первая задача

  Для чтения больших файлов можно использовать генератор с конструкцией yield.
  Это позволяет читать файл построчно, не загружать файл в память
  Т.к. по задаче мы не имеем право держать в памяти больше 1000  элементов массива, необходимо периодически
  сбрасывать данные на диск предварительно смержив с тем что есть уже.
  Для этого считываем то что есть уже, изменяем данные при необходимости, сбрасывая периодически во временный файл то, что не нашлось в текущем массиве.
  То, что нашлось во временный файл не сбрасываем, а изменяем текущий.
  В конце скидываем на диск все и делаем временный файл основным.
  И так, пока не закончится весь файл.
  Для теста я взял условие, что нельзя хранить больше 3 элементов массива в массиве над которым идет работа.

Вторая задача

 К этой задаче я вижу два подхода.
1. Выбирать пользователей, которым нравится то, что нравится авторизованному пользователю, и выбирать наиболее популярные из тех которые он пролайкал тоже.
	Учитывая, что про пользователей в задаче ничего не сказано, но сказано про категории и лайки к ним, вытекает второе решение:
2. Выбрать лучшие видео из категорий, которые пользователю тоже нравятся.

  Выбор категорий, в которых пользователь пролайкал видео, выходят за рамки задачи, следовательно решением будет:
  Генерация рейтингов видео на основе лайков и дислайков(количество просмотров не является оценивающей характеристикой).
  Существует несколько подходов сортировок на основе оценок. Лучший:
  Рейтинг = Нижняя граница доверительного интервала Вильсона (Wilson) для параметра Бернулли
 
  Для хранения сгенерированных рекомендаций используется таблица video_recomendations (video_id, ci_lower_bound, category_id)
  Для получения видео по категории используется метод getBestVideosByCategory
  Для генерации видео используется метод generateVideos
  Для неавторизованных пользователей можно показывать просто лучшие видео
  
  